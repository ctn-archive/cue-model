from glob import glob
import os.path
import traceback
import warnings

import matplotlib.pyplot as plt
import numpy as np
from psyrun.store import AutodetectStore
from scipy.stats import kurtosis
import seaborn as sns

from imem.analysis import analysis
from imem.analysis.conversion import convert, DataRep
from imem.analysis.io import read_exp_data
from imem.protocols import PROTOCOLS


store = AutodetectStore()


def evaluate(path):
    for proto_name, proto in PROTOCOLS.items():
        try:
            proto_path = os.path.join(path, proto_name)
            if os.path.exists(proto_path):
                exp_data = read_exp_data(proto.exp_data)
                model_data = DataRep(
                    'psyrun', store.load(locate_results_file(proto_path)))

                if proto.serial:
                    fig = plt.figure(figsize=(12, 4))
                    evaluate_serial_recall(
                        proto, exp_data, model_data, fig=fig)
                else:
                    fig = plt.figure(figsize=(12, 12))
                    evaluate_free_recall(proto, exp_data, model_data, fig=fig)

                fig.suptitle(path + ', ' + proto_name)
                fig.tight_layout(rect=(.0, .0, 1., .95))
        except Exception as err:
            traceback.print_exc()
            warnings.warn(str(err))


def evaluate_serial_recall(proto, exp_data, model_data, fig=None):
    if fig is None:
        fig = plt.gcf()

    evaluate_serial_pos_curve(
        proto, exp_data, model_data, ax=fig.add_subplot(1, 2, 1))
    evaluate_transpositions(
        proto, exp_data, model_data, ax=fig.add_subplot(1, 2, 2))


def evaluate_free_recall(proto, exp_data, model_data, fig=None):
    if fig is None:
        fig = plt.gcf()

    evaluate_successful_recalls(
        proto, exp_data, model_data, ax=fig.add_subplot(3, 2, 1))
    evaluate_successful_recall_dist(
        proto, exp_data, model_data, ax=fig.add_subplot(3, 2, 2))
    evaluate_p_first_recall(
        proto, exp_data, model_data, ax=fig.add_subplot(3, 2, 3))
    evaluate_crp(
        proto, exp_data, model_data, ax=fig.add_subplot(3, 2, 4))
    evaluate_serial_pos_curve(
        proto, exp_data, model_data, strict=False, ax=fig.add_subplot(3, 2, 5))


def evaluate_successful_recalls(proto, exp_data, model_data, ax=None):
    cp = iter(sns.color_palette())

    if ax is None:
        ax = plt.gca()

    plot_successful_recalls(
        exp_data, proto.n_items, color=next(cp), label="experimental", ax=ax)
    plot_successful_recalls(
        model_data, proto.n_items, color=next(cp), label="model", ax=ax)

    ax.set_xlim(-0.5, proto.n_items + 0.5)
    ax.set_xlabel("# successful recalls")
    ax.set_ylabel("Proportion")
    ax.legend()


def evaluate_successful_recall_dist(proto, exp_data, model_data, ax=None):
    ev_exp_data = convert(exp_data, 'success_count')
    ev_model_data = convert(model_data, 'success_count')
    plot_dist_stats(ev_exp_data.data, ax)
    plot_dist_stats(ev_model_data.data, ax)


def evaluate_p_first_recall(proto, exp_data, model_data, ax=None):
    if ax is None:
        ax = plt.gca()

    ev_exp_data = analysis.p_first_recall(exp_data)
    ev_exp_data['p_first'].plot(
        marker='o', label="experimental", ax=ax,
        yerr=ev_exp_data[['ci_low', 'ci_upp']].values.T)
    ev_model_data = analysis.p_first_recall(model_data)
    ev_model_data['p_first'].plot(
        marker='o', label="model", ax=ax,
        yerr=ev_model_data[['ci_low', 'ci_upp']].values.T)

    ax.set_xlabel("Serial position")
    ax.set_ylabel("Probability of first recall")
    ax.legend()
    ax.set_ylim(bottom=0.)


def evaluate_crp(proto, exp_data, model_data, ax=None, limit=6):
    if ax is None:
        ax = plt.gca()

    with warnings.catch_warnings():
        # Warning generated by plotting and I am not sure why. It doesn't seem
        # to effect anything, though.
        warnings.filterwarnings(
            'ignore', '.*converting a masked element to nan.*')

        ev_exp_data = analysis.crp(exp_data)
        ev_exp_data['crp'].plot(
            marker='o', label="experimental", ax=ax,
            yerr=np.copy(ev_exp_data[['ci_low', 'ci_upp']].values.T))

        ev_model_data = analysis.crp(model_data)
        ev_model_data['crp'].plot(
            marker='o', label="model", ax=ax,
            yerr=np.copy(ev_model_data[['ci_low', 'ci_upp']].values.T))

    ax.set_xlim(-limit, limit)
    ax.set_xlabel("Lag position")
    ax.set_ylabel("CRP")
    ax.legend()


def evaluate_serial_pos_curve(
        proto, exp_data, model_data, strict=True, ax=None):
    if ax is None:
        ax = plt.gca()

    ev_exp_data = analysis.serial_pos_curve(exp_data, strict=strict)
    ev_exp_data['correct'].plot(
        marker='o', label="experimental", ax=ax,
        yerr=ev_exp_data[['ci_low', 'ci_upp']].values.T)
    ev_model_data = analysis.serial_pos_curve(model_data, strict=strict)
    ev_model_data['correct'].plot(
        marker='o', label="model", ax=ax,
        yerr=ev_model_data[['ci_low', 'ci_upp']].values.T)

    ax.set_xlabel("Serial position")
    ax.set_ylabel("Proportion correct recalls")
    ax.set_ylim(0, 1)
    ax.legend()


def evaluate_transpositions(proto, exp_data, model_data, ax=None):
    if ax is None:
        ax = plt.gca()

    data = analysis.transpositions(model_data)
    ax.bar(
        data.index, data['p_transpose'],
        width=1., color=sns.color_palette()[0],
        yerr=data[['ci_low', 'ci_upp']].values.T)
    lim = np.max(np.abs(data.index.values))
    ax.set_xlim(-lim, lim)


def plot_successful_recalls(
        n_successfull, n_items, ax=None, label=None, **kwargs):
    n_successfull = convert(n_successfull, 'success_count').data
    if ax is None:
        ax = plt.gca()
    ax.hist(
        n_successfull, bins=n_items + 1, range=(-0.5, n_items + 0.5),
        density=True, alpha=0.5, label=label, **kwargs)
    if label is not None:
        label = label + ' (mean)'
    ax.axvline(x=np.mean(n_successfull.data), label=label, **kwargs)


def plot_dist_stats(data, ax=None):
    if ax is None:
        ax = plt.gca()

    mean, (mean_l, mean_u) = analysis.aggregate_measure(data, np.mean)
    std, (std_l, std_u) = analysis.aggregate_measure(data, np.std)
    kur, (kur_l, kur_u) = analysis.aggregate_measure(data, kurtosis)

    ax.errorbar(range(3), [mean, std, kur], yerr=[
        [mean - mean_l, std - std_l, kur - kur_l],
        [mean_u - mean, std_u - std, kur_u - kur]], marker='o')
    # TODO remove lines
    # TODO label plot


def locate_results_file(path):
    candidates = glob(os.path.join(path, 'result.*'))
    if len(candidates) < 1:
        raise FileNotFoundError("No results file found in {!r}.".format(path))
    elif len(candidates) > 1:
        warnings.warn(
            "Found multiple results file in {!r}, using {!r}.".format(
                path, candidates[0]))
    return candidates[0]
